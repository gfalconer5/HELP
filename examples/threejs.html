<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #container {
      position: fixed;
      top: 0;
      z-index: 20000;
      width: 200px;
      height: 150px;
    }

    #face {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    video {
      position: absolute;
      transform:scaleX(-1);
      -webkit-transform:scaleX(-1);
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="video" autoplay></video>
    <canvas id="face" ></canvas>
  </div>


  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- TensorFlow with WASM/WebGL backend -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm/dist/tf-backend-wasm.js"></script>
  <script>tf.setBackend('wasm').then(() => main());</script>

  <!-- TensorFlow model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

  <script>

    let topcamera, scene, renderer, mesh;

    let helper;

    init();
    animate();

    let seed = 0.016;
    Math.random = function () {

      let x = Math.sin( seed ++ ) * 10000;
      return x - Math.floor( x );

    };

    function init() {

      let dummy = new THREE.Object3D();
      let xCount = 5;
      let yCount = 15;
      let count = xCount * yCount;

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild( renderer.domElement );

      scene = new THREE.Scene();

      maincamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 70 );
      maincamera.position.set( 0, 0, 8 );

      topcamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 300 );
      topcamera.position.set( 0, 80, 4 );
      topcamera.lookAt( 0, 0, 0 );

      helper = new THREE.CameraHelper( maincamera );
      //scene.add( helper );

      let cameraRig = new THREE.Group();
      cameraRig.add( maincamera );
      scene.add( cameraRig );

      new THREE.GLTFLoader().load( 'res/head.glb', function ( gltf ) {

        let instanceColors = [];

        for ( let i = 0; i < 3 * count; i ++ ) {

          instanceColors.push( Math.random() );

        }

        let geometry = gltf.scene.children[ 0 ].geometry;
        geometry.setAttribute( 'instanceColor', new THREE.InstancedBufferAttribute( new Float32Array( instanceColors ), 3 ) );
        geometry.computeVertexNormals();
        geometry.scale( 0.5, 0.5, 0.5 );

        new THREE.TextureLoader().load( 'res/matcap.jpg', function ( texture ) {

          texture.encoding = THREE.sRGBEncoding;
          let material = new THREE.MeshMatcapMaterial( { color: 0xaaaaff, matcap: texture } );

          material.onBeforeCompile = function ( shader ) {

            shader.vertexShader = shader.vertexShader
              .replace( 'void main() {', [
                  'attribute vec3 instanceColor;',
                  'varying vec3 vInstanceColor;',
                  'void main() {',
                  'vInstanceColor = instanceColor;'
                ].join( '\n' ) );

            shader.fragmentShader = shader.fragmentShader
              .replace( '#include <common>', 'varying vec3 vInstanceColor;' )
              .replace( 'vec4 diffuseColor = vec4( diffuse, opacity );',
                'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );' );

          };

          mesh = new THREE.InstancedMesh( geometry, material, count );

          if ( mesh ) {

            let i = 0;
            let xoffset = 5;
            let yoffset = 4;

            for ( let x = 0; x < xCount; x ++ ) {

              for ( let z = 0; z < yCount; z ++ ) {

                dummy.position.set( xoffset * ( xCount / 2 - x - 0.5 ), 0, - yoffset * z );
                dummy.updateMatrix();
                mesh.setMatrixAt( i ++, dummy.matrix );

              }

            }

          }

          scene.add( mesh );

        } );

      } );

      window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

      topcamera.aspect = window.innerWidth / window.innerHeight;
      topcamera.updateProjectionMatrix();
      maincamera.aspect = window.innerWidth / window.innerHeight;
      maincamera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

      //helper.update();
      renderer.render( scene, maincamera );
      requestAnimationFrame( animate );

    }

    //==============================

    async function setupWebcam() {

      if ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {
        navigator.mediaDevices.getUserMedia( { video: true } ).then( function ( stream ) {
          video.srcObject = stream;
          video.play();
        });
      }
      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          video.play();
          videoWidth = video.videoWidth;
          videoHeight = video.videoHeight;
          video.width = videoWidth;
          video.height = videoHeight;
          resolve(video);
        };
      });
    }

    let video = document.getElementById('video');
    let position0, fov0, webcam, screenDist, eyeDist;
    let position1;
    let whitebox, screen;

    function initControl( video, camera, screenDistance, camFov, eyeDistance ) {

      screenDist = screenDistance;
      eyeDist = eyeDistance * video.width;
      position0 = camera.position.clone();
      fov0 = camera.fov;

      // set webcam
      webcam = new THREE.PerspectiveCamera( camFov, video.width / video.height, screenDist )
      let p = new THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion )
          .multiplyScalar( screenDist ).add( camera.position );
      webcam.position.copy( p );
      webcam.lookAt( new THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion ).negate().add( camera.position ) );

      // cam rigs
      let group = new THREE.Group();
      group.add( webcam );
      scene.add( group );
      let helper = new THREE.CameraHelper( webcam );
      //scene.add( helper );
      scene.add( mesh );

      // sceen plane
      // let size = 2 * screenDist * Math.sin( .5 * camera.fov );
      // let plane = new THREE.PlaneBufferGeometry( size, size );
      // let mat = new THREE.MeshBasicMaterial();
      // screen = new THREE.Mesh( plane, mat );
      // screen.position.copy( webcam.position );
      // screen.lookAt( position0 );
      // scene.add( screen );

      // whitebox
      // let geom = new THREE.BoxBufferGeometry( 1, 1, 1 );
      // whitebox = new THREE.Mesh( geom, mat );
      // whitebox.position.copy( position0 );
      // scene.add( whitebox );

    }

    async function setupPage () {
      await setupWebcam();

      canvas = document.getElementById('face');
      canvas.width = videoWidth;
      canvas.height = videoHeight;
      ctx = canvas.getContext('2d');
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";

      model = await blazeface.load();
      initControl( video, maincamera, 8, 35, 0.23 );
      renderPrediction();
    };

    let dist = null;
    let eye0 = null;
    let eye1 = null;
    let distSmooth = 0.2;
    let eyeSmooth = 0.7;

    async function renderPrediction() {
      let predictions = await model.estimateFaces(video, false, true, true);

      if (predictions.length > 0) {
        let landmarks = predictions[0].landmarks;


        let eye0C = new THREE.Vector2( landmarks[ 0 ][ 0 ], landmarks[ 0 ][ 1 ] );
        let eye1C = new THREE.Vector2( landmarks[ 1 ][ 0 ], landmarks[ 1 ][ 1 ] );
        if ( eye0 === null ) {
          eye0 = eye0C;
          eye1 = eye1C;
        } else {
          eye0.multiplyScalar( 1 - eyeSmooth ).add( eye0C.multiplyScalar(eyeSmooth) );
          eye1.multiplyScalar( 1 - eyeSmooth ).add( eye1C.multiplyScalar(eyeSmooth) );
        }

        let d = eye0.distanceTo( eye1 ) * 0.32;


        // update 2d canvas

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'lime';
        ctx.beginPath();
        ctx.ellipse( eye0.x, eye0.y, d, d, 0, 0, 2 * Math.PI );
        ctx.ellipse( eye1.x, eye1.y, d, d, 0, 0, 2 * Math.PI );
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.font = Math.round( d * 1.7 ) + 'px serif';
        ctx.fillText( '$', eye0.x - d * .5, eye0.y + d * .5 );
        ctx.fillText( '$', eye1.x - d * .5, eye1.y + d * .5 );

        d = d * 0.45;
        let distC = screenDist * eyeDist / d * .06;
        if ( dist === null) {
          dist = distC;
        } else {
          dist = distC * distSmooth + dist * ( 1 - distSmooth );
        }
        let thirdEye = eye0.clone().add( eye1 ).multiplyScalar( 0.5 );
        thirdEye.divide( new THREE.Vector2( video.width, video.height ).multiplyScalar( - 0.5 ) ).add( new THREE.Vector2( 1, 1 ) );

        //threejs stuff

        let ray = new THREE.Ray();
        ray.origin.setFromMatrixPosition( webcam.matrixWorld );
        ray.direction.set( thirdEye.x, thirdEye.y, 0.5 ).unproject( webcam ).sub( ray.origin ).normalize();

        let headPos = new THREE.Vector3();
        ray.at( dist, headPos );

        maincamera.position.copy( headPos );
        maincamera.lookAt( webcam.position );
        maincamera.fov = 6 * fov0 / dist;
        maincamera.updateProjectionMatrix();

      }

      requestAnimationFrame(renderPrediction);
    };

    setupPage();
  </script>

</body>
</html>